'use strict';

<<<<<<< HEAD
var typeOf = require('kind-of');
var define = require('define-property');
var extend = require('extend-shallow');
=======
>>>>>>> da58736f2e682a40f89c301964181f1426b3966b
var Snapdragon = require('snapdragon');
var compilers = require('./compilers');
var parsers = require('./parsers');
var utils = require('./utils');

/**
 * Customize Snapdragon parser and renderer
 */

function Braces(options) {
<<<<<<< HEAD
  this.options = extend({}, options);
=======
  this.options = utils.extend({}, options);
>>>>>>> da58736f2e682a40f89c301964181f1426b3966b
}

/**
 * Initialize braces
 */

Braces.prototype.init = function(options) {
<<<<<<< HEAD
  if (this.isInitialized) return;
  this.isInitialized = true;
=======
>>>>>>> da58736f2e682a40f89c301964181f1426b3966b
  var opts = utils.createOptions({}, this.options, options);
  this.snapdragon = this.options.snapdragon || new Snapdragon(opts);
  this.compiler = this.snapdragon.compiler;
  this.parser = this.snapdragon.parser;

  compilers(this.snapdragon, opts);
  parsers(this.snapdragon, opts);

  /**
   * Call Snapdragon `.parse` method. When AST is returned, we check to
   * see if any unclosed braces are left on the stack and, if so, we iterate
   * over the stack and correct the AST so that compilers are called in the correct
   * order and unbalance braces are properly escaped.
   */

<<<<<<< HEAD
  define(this.snapdragon, 'parse', function(pattern, options) {
=======
  utils.define(this.snapdragon, 'parse', function(pattern, options) {
>>>>>>> da58736f2e682a40f89c301964181f1426b3966b
    var parsed = Snapdragon.prototype.parse.apply(this, arguments);
    this.parser.ast.input = pattern;

    var stack = this.parser.stack;
    while (stack.length) {
      addParent({type: 'brace.close', val: ''}, stack.pop());
    }

    function addParent(node, parent) {
<<<<<<< HEAD
      define(node, 'parent', parent);
=======
      utils.define(node, 'parent', parent);
>>>>>>> da58736f2e682a40f89c301964181f1426b3966b
      parent.nodes.push(node);
    }

    // add non-enumerable parser reference
<<<<<<< HEAD
    define(parsed, 'parser', this.parser);
=======
    utils.define(parsed, 'parser', this.parser);
>>>>>>> da58736f2e682a40f89c301964181f1426b3966b
    return parsed;
  });
};

/**
<<<<<<< HEAD
=======
 * Lazily initialize braces
 */

Braces.prototype.lazyInit = function(options) {
  if (!this.isInitialized) {
    this.isInitialized = true;
    this.init(options);
  }
};

/**
>>>>>>> da58736f2e682a40f89c301964181f1426b3966b
 * Decorate `.parse` method
 */

Braces.prototype.parse = function(ast, options) {
<<<<<<< HEAD
  if (typeOf(ast) === 'object' && ast.nodes) return ast;
  this.init(options);
=======
  if (utils.isObject(ast) && ast.nodes) return ast;
  this.lazyInit(options);
>>>>>>> da58736f2e682a40f89c301964181f1426b3966b
  return this.snapdragon.parse(ast, options);
};

/**
 * Decorate `.compile` method
 */

Braces.prototype.compile = function(ast, options) {
  if (typeof ast === 'string') {
    ast = this.parse(ast, options);
  } else {
<<<<<<< HEAD
    this.init(options);
  }
  return this.snapdragon.compile(ast, options);
=======
    this.lazyInit(options);
  }
  var res = this.snapdragon.compile(ast, options);
  return res;
>>>>>>> da58736f2e682a40f89c301964181f1426b3966b
};

/**
 * Expand
 */

Braces.prototype.expand = function(pattern) {
  var ast = this.parse(pattern, {expand: true});
  return this.compile(ast, {expand: true});
};

/**
 * Optimize
 */

Braces.prototype.optimize = function(pattern) {
  var ast = this.parse(pattern, {optimize: true});
  return this.compile(ast, {optimize: true});
};

/**
 * Expose `Braces`
 */

module.exports = Braces;
